{"name":"Box2dane","body":"Box2DANE\r\n========\r\n\r\nBox2D AIR Native Extension\r\n\r\n-- Project Setup --\r\n\r\nThe Box2DANEC folder should be in your src directory of your project in Eclipse. Also, Box2D\r\nitself should be within your src folder. \r\n\r\nFor the Actionscript side of things, the project is a Flashdevelop project. So you'll need this\r\nif you want to conveniently work with the AS side.\r\n\r\n-- Concept --\r\n\r\nThe general idea for the design of this AIR Native Extension is that the Actionscript side should\r\nfunction purely as an interface to the methods on the native side. As such, every public method\r\nwithin Box2D (the C++ side) has been exposed to the Actionscript code, and every publically \r\navailable variable within the native Box2D side has been exposed to the Actionscript side as\r\nwell through getters and setters.\r\n\r\nBasically for every native function in Box2D C++ there is a C function callback that the flash\r\nvirtual machine is able to invoke through ExtensionContext instances. We then use the context\r\nto pull up the associated user data from C (which is usually the class instance on the native side)\r\nand invoke the corresponding method or read/write the appropriate property on the native side.\r\n\r\nWithin these C callbacks, we can also contruct new Actionscript class instances and return them\r\nto the Flash side of things. This is the main reason why our format for the context initializer\r\nis either:\r\n\r\n\"DesiredClassType\"\r\n\r\nor\r\n\r\n\"DesiredClassType::ObjectAddressInMemory\"\r\n\r\nBasically by using this format, we can attach the memory address of an object on the native side\r\nthat we specifically want our new Actionscript class instance to represent. So when we access properties\r\nor methods on that Actionscript object, those callbacks are invoked specifically on the native object\r\nat the memory address specified.\r\n\r\nNote however that the Actionscript developer should NEVER be providing this memory address to any\r\nof the Box2DANE Actionscript classes. This exists solely for the native C side to control. Here is\r\nan example of where this functionality is taken advantage of. Consider the following case:\r\n\r\n----- Example -----\r\n\r\nActionscript 3 Class instance of b2World is created. The context initalizer is called, with the \r\nargument of simply \"b2World\". This means the initializer will create a brand new instance of a \r\nb2World on the native side, and then configure the Actionscript 3 instance of that b2World to \r\ndirectly access and read/modify from this new native b2World instance.\r\n\r\nNow we have an Actionscript 3 instance of b2World, which directly invokes changes or reads from\r\na specific b2World instance. Now we want to create a b2Body instance within that world. Well, \r\nthe lifecycle of a b2Body is controlled explicitly by the b2World it belongs to. So on the Actionscript\r\nside the method b2World.createBody(...); needs to return an Actionscript 3 instance of b2Body at the\r\nEXACT same time a new instance of b2Body is created on the native side. So what happens is behind the\r\nscenes, the b2World.createBody C callback actually returns a String which holds the native address of a\r\nnew instance of b2Body. We then create a new b2Body Actionscript 3 instance ON THE NATIVE SIDE and\r\nset this new instance to be paired with the b2Body we just created on the native side. This is where\r\nthat native address setting takes place and only ever should take place. We then return the b2Body\r\nActionscript 3 instance to the AS3 side and the AS3 developer has no idea because all this stuff\r\nis hidden away from him/her.\r\n\r\n----- End Example -----\r\n\r\n-- Getters and Setters --\r\n\r\nThe idea on the AS3 side is to simply interface with a native instance of the class we're using. So,\r\nfor example, if we have an AS3 b2AABB instance, any readable property on it is a getter and setter\r\nthat actually just does an extensionContext.call(). In this case we need to consider the very real\r\npossibility of creating a ton of new native instances every time a property is read. To\r\ndeal with this issue, once a property has been set on the AS3, if it exists when the getter is called\r\nwe simply update that instance and return it again. For example:\r\n\r\n\tpublic function get lowerBound():b2Vec2\r\n\t{\r\n\t\t/* In this getter, we don't want to be creating a new b2Vec2 every single\r\n\t\t * time we want to read the lowerBound variable. So, if we have already created one, we'll\r\n\t\t * simply pass it as a parameter to this getter and adjust it's values to match the values\r\n\t\t * of the b2aabb_instance.lowerBound vector.\r\n\t\t */\r\n\t\tif (_lowerBound != null) {\r\n\t\t\tnativeContext.call(\"ane_b2AABB_getter_lowerBound\", _lowerBound);\r\n\t\t}else {\r\n\t\t\t_lowerBound = nativeContext.call(\"ane_b2AABB_getter_lowerBound\") as b2Vec2;\r\n\t\t}\r\n\t\t\r\n\t\treturn _lowerBound;\r\n\t}\r\n\t\r\nOn the native side, the \"ane_b2AABB_getter_lowerBound\" callback method simply checks to see if we've\r\nsupplied a function argument or not. If we have, it pulls up that native instance and updates it. If\r\nwe have not, it will create and return a new instance. This same practice is used within all like\r\nclasses that have access controlled properties. Just for completeness, the native callback looks\r\nlike this:\r\n\r\n\tFREObject ane_b2AABB_getter_lowerBound(FREContext ctx, void* functionData, uint32_t argc, FREObject argv[]) {\r\n\t\tvoid* nativeData;\r\n\t\tFREGetContextNativeData(ctx, &nativeData);\r\n\t\tb2AABB* b2AABB_instance = (b2AABB*)(nativeData);\r\n\r\n\t\t/* This getter function can work one of two ways. It can either accept a single parameter which\r\n\t\t * is an AS3 b2Vec2 instance, from which we will retrive the native b2Vec2 and assign it to the\r\n\t\t * value of b2AABB_instance->lowerBound. OR, if no argument is received, it means we need to create\r\n\t\t * a new b2Vec2 instance, set it equal to b2AABB_instance->lowerBound and return it.\r\n\t\t */\r\n\r\n\t\tFREObject lowerBoundAS3Object;\r\n\r\n\t\tif(argc == 1) {\r\n\t\t\t/* An instance has been supplied. Update it */\r\n\t\t\tlowerBoundAS3Object = argv[0];\r\n\t\t\tvoid* lowerBoundb2Vec2Instance = FREGetNativeInstancePointer(lowerBoundAS3Object);\r\n\t\t\tb2Vec2* lowerBound = (b2Vec2*)lowerBoundb2Vec2Instance;\r\n\t\t\t*lowerBound = b2AABB_instance->lowerBound;\r\n\t\t}else{\r\n\t\t\t/*\tCreate a new b2Vec2 AS3 instance */\r\n\r\n\t\t\tb2Vec2* lowerBound = new b2Vec2(b2AABB_instance->lowerBound);\r\n\r\n\t\t\t//AS3 b2Vec2 constructor arguments\r\n\t\t\tFREObject valueX, valueY, b2Vec2MemAddress, b2Vec2AS3Object, initException;\r\n\t\t\tFREObject constructorArguments[3];\r\n\t\t\tFRENewObjectFromInt32(0, &valueX);\r\n\t\t\tFRENewObjectFromInt32(0, &valueY);\r\n\t\t\tFRENewObjectFromUTF8Pointer((void*)lowerBound, &b2Vec2MemAddress);\r\n\t\t\tconstructorArguments[0] = valueX;\r\n\t\t\tconstructorArguments[1] = valueY;\r\n\t\t\tconstructorArguments[2] = b2Vec2MemAddress;\r\n\t\t\t//\r\n\r\n\t\t\tconst uint8_t* className = (const uint8_t*)\"ca.digitalarchitect.box2dane.common.b2Vec2\";\r\n\r\n\t\t\tFREResult objInitResult = FRENewObject(className, 3, constructorArguments, &b2Vec2AS3Object, &initException);\r\n\r\n\t\t\tif(objInitResult != FRE_OK) {\r\n\t\t\t\tFREError(\"Error creating b2Vec2 object in function ane_b2AABB_getter_lowerBound\");\r\n\t\t\t}\r\n\t\t\t/*\tEnd Create a new b2Vec2 AS3 instance */\r\n\r\n\t\t\tlowerBoundAS3Object = b2Vec2AS3Object;\r\n\t\t}\r\n\r\n\t\treturn lowerBoundAS3Object;\r\n\t}\r\n","google":"","tagline":"Box2D AIR Native Extension","note":"Don't delete this file! It's used internally to help with page regeneration."}